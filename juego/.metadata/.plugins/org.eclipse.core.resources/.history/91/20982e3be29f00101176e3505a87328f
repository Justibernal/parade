package servidor;

import persistencia.Persistencia;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.*;

import modelo.core.*;
import modelo.puntaje.EntradaClasificacion;
import modelo.puntaje.TablaClasificacion;
import modelo.reglas.ReglasParade;
import net.*;

public class ServidorJuegoImpl extends UnicastRemoteObject implements ServidorJuegoRemoto {
  private static final long serialVersionUID = 1L;

  private final Map<String, CallbackClienteRemoto> clientes  = new LinkedHashMap<>();
  private final Map<String, EstadoJuego.Jugador>   jugadores = new LinkedHashMap<>();
  private final EstadoJuego estado = new EstadoJuego();
  private final ReglasParade reglas = new ReglasParade();

  public ServidorJuegoImpl() throws RemoteException { super(); }

//=== RMI API ===
@Override
public synchronized String join(String nombre, CallbackClienteRemoto cb) throws RemoteException {
   // === VERIFICAR CLIENTES DESCONECTADOS ANTES DE UNIRSE ===
   verificarClientesActivos();
   
// === RESETEO: Si no hay clientes conectados, resetear partida ===
   if (clientes.isEmpty()) {
       resetearPartidaCompleta(); 
   }
   
   // === CARGA AUTOMÁTICA: Si es el primer jugador y hay partida guardada ===
   if (clientes.isEmpty() && estado.jugadores.isEmpty()) {
       cargarPartidaSiExiste();
   }
   
   // 1. Buscar si ya existe un jugador con ese nombre en la partida ACTUAL
   for (EstadoJuego.Jugador j : estado.jugadores.values()) {
       if (j.nombre.equals(nombre)) {
           // Reutilizamos al jugador existente
           clientes.put(j.id, cb); // actualizar callback
           broadcast("[info] " + nombre + " se reconectó.");
           push();
           return j.id;
       }
   }

   // 2. Si no existe, creamos un jugador nuevo
   String id = UUID.randomUUID().toString();
   var j = new EstadoJuego.Jugador();
   j.id = id;
   j.nombre = nombre;

   jugadores.put(id, j);
   estado.jugadores.put(id, j);
   clientes.put(id, cb);

   broadcast("Se unió " + nombre);
   push();
   return id;
}

//=== MÉTODO PARA LIMPIAR CLIENTES DESCONECTADOS ===
public synchronized void verificarClientesActivos() {
  // Crear copia para evitar ConcurrentModification
  List<String> desconectados = new ArrayList<>();
  
  for (Map.Entry<String, CallbackClienteRemoto> entry : clientes.entrySet()) {
      try {
          entry.getValue().onEvent("[ping]"); // Test de conexión
      } catch (RemoteException e) {
          // Cliente desconectado
          desconectados.add(entry.getKey());
      }
  }
  
  // Remover los desconectados
  for (String id : desconectados) {
      clientes.remove(id);
      System.out.println("Cliente desconectado: " + id);
  }
  
  // Si no hay clientes, resetear partida
  if (clientes.isEmpty() && !estado.jugadores.isEmpty()) {
      resetearPartidaCompleta();
  }
}

//=== MÉTODO PARA CARGAR PARTIDA AUTOMÁTICAMENTE ===
private void cargarPartidaSiExiste() {
   try {
       EstadoJuego saved = Persistencia.load();
       if (saved != null) {
           copiarEstadoCompleto(saved, this.estado);
           jugadores.clear();
           jugadores.putAll(estado.jugadores);
           
           System.out.println("✓ Partida cargada automáticamente: " + 
                            estado.jugadores.size() + " jugadores, " +
                            estado.cartasMazoRestantes + " cartas en mazo");
           broadcast("[info] Partida anterior cargada automáticamente. Únanse los mismos jugadores.");
       }
   } catch (Exception e) {
       System.err.println("No se pudo cargar partida automáticamente: " + e.getMessage());
       // No broadcast para no molestar a los usuarios
   }
}

//=== MÉTODO PARA COPIAR ESTADO COMPLETO ===
private void copiarEstadoCompleto(EstadoJuego fuente, EstadoJuego destino) {
   // Limpiar destino primero
   destino.jugadores.clear();
   destino.desfile.clear();
   destino.pendientesEleccion.clear();
   
   // Copiar jugadores (IMPORTANTE: copia profunda)
   for (var entry : fuente.jugadores.entrySet()) {
       EstadoJuego.Jugador jOrig = entry.getValue();
       EstadoJuego.Jugador jCopia = new EstadoJuego.Jugador();
       
       jCopia.id = jOrig.id;
       jCopia.nombre = jOrig.nombre;
       jCopia.mano.addAll(jOrig.mano);       // Copiar mano
       jCopia.pilas.putAll(jOrig.pilas);     // Copiar pilas
       
       destino.jugadores.put(entry.getKey(), jCopia);
   }
   
   // Copiar resto de campos
   destino.desfile.addAll(fuente.desfile);
   destino.turnoDe = fuente.turnoDe;
   destino.cartasMazoRestantes = fuente.cartasMazoRestantes;
   destino.juegoTerminado = fuente.juegoTerminado;
   destino.ultimaRonda = fuente.ultimaRonda;
   destino.causaFin = fuente.causaFin;
   destino.pendientesEleccion.addAll(fuente.pendientesEleccion);
}

private void resetearPartidaCompleta() {
   estado.jugadores.clear();
   estado.desfile.clear();
   estado.turnoDe = null;
   estado.cartasMazoRestantes = 0;
   estado.juegoTerminado = false;
   estado.ultimaRonda = false;
   estado.causaFin = null;
   estado.pendientesEleccion.clear();
   
   jugadores.clear();
   
   System.out.println("=== NUEVA PARTIDA - Estado reiniciado ===");
}

  @Override
  public synchronized void sendChat(String id, String msg) throws RemoteException {
    String nombre = (estado.jugadores.get(id) != null)
        ? estado.jugadores.get(id).nombre
        : id;
    broadcast("[CHAT] " + nombre + ": " + msg);
  }

  @Override
  public synchronized void start() throws RemoteException {
    var lista = new ArrayList<>(jugadores.values());
    if (lista.size() < 2) { broadcast("[info] Se necesitan al menos 2 jugadores."); return; }

    // reset estado final
    estado.ultimaRonda = false;
    estado.causaFin = null;
    estado.pendientesEleccion.clear();
    estado.juegoTerminado = false;

    reglas.iniciar(estado, lista);
    broadcast("Partida iniciada");
    push();
  }

  @Override
  public synchronized void playCard(String playerId, int handIndex) throws RemoteException {
    var jugadorActual = estado.jugadores.get(playerId);
    if (jugadorActual == null) return;

    if (!Objects.equals(estado.turnoDe, playerId)) {
      var cb = clientes.get(playerId);
      if (cb != null) cb.onEvent("No es tu turno.");
      return;
    }
    if (handIndex < 0 || handIndex >= jugadorActual.mano.size()) {
      var cb = clientes.get(playerId);
      if (cb != null) cb.onEvent("Índice inválido: " + handIndex + " (usa 0.." + (jugadorActual.mano.size()-1) + ")");
      return;
    }

    // Jugar la carta usando reglas
    reglas.jugarCarta(estado, playerId, handIndex);

 // Activar fase final si corresponde (sin mazo o alguien completó 6 colores)
    if (!estado.ultimaRonda) {
      boolean sinMazo = (estado.cartasMazoRestantes <= 0);
      boolean seisColores = estado.jugadores.values().stream()
          .anyMatch(jg -> jg.pilas.keySet().size() >= Color.values().length);

      if (sinMazo || seisColores) {
        estado.ultimaRonda = true;
        estado.causaFin = sinMazo ? "sin_mazo" : "seis_colores";
        estado.turnoDe = null; // ya no hay turnos; cada uno elige sus 2 cartas
        estado.pendientesEleccion.clear();
        estado.pendientesEleccion.addAll(estado.jugadores.keySet());

        broadcast("¡Última ronda! Motivo: " +
            (sinMazo ? "se agotó el mazo" : "un jugador completó los 6 colores") +
            ". Cada jugador debe elegir 2 cartas de su mano para mover a sus pilas.");
        push();
        return;
      }
    }

    // Si no entramos en fase final, solo refrescar estado normal
    push();
  }

  // === FASE FINAL: elección 2 cartas ===
  @Override
  public synchronized void chooseFinalCards(String playerId, int[] indices) throws RemoteException {
    var j = estado.jugadores.get(playerId);
    if (j == null) return;

    // Si no estamos en fase final, aviso y salgo
    if (!estado.ultimaRonda) {
      var cb = clientes.get(playerId);
      if (cb != null) try { cb.onEvent("Aún no es la fase final."); } catch (Exception ignore) {}
      return;
    }
    // Evitar doble envío del mismo jugador
    if (estado.pendientesEleccion == null || !estado.pendientesEleccion.contains(playerId)) {
      var cb = clientes.get(playerId);
      if (cb != null) try { cb.onEvent("Ya registraste tu elección final."); } catch (Exception ignore) {}
      return;
    }

    // Validaciones
    if (indices == null || indices.length != 2) {
      var cb = clientes.get(playerId);
      if (cb != null) try { cb.onEvent("Debés elegir exactamente 2 cartas de tu mano."); } catch (Exception ignore) {}
      return;
    }
    java.util.Set<Integer> set = new java.util.HashSet<>();
    for (int ix : indices) {
      if (ix < 0 || ix >= j.mano.size()) {
        var cb = clientes.get(playerId);
        if (cb != null) try { cb.onEvent("Índice inválido: " + ix); } catch (Exception ignore) {}
        return;
      }
      if (!set.add(ix)) {
        var cb = clientes.get(playerId);
        if (cb != null) try { cb.onEvent("Los índices deben ser distintos."); } catch (Exception ignore) {}
        return;
      }
    }

    // Mover cartas a pilas (orden descendente para no desplazar índices)
    java.util.Arrays.sort(indices);
    for (int k = indices.length - 1; k >= 0; k--) {
      Carta c = j.mano.remove(indices[k]);
      j.pilas.computeIfAbsent(c.getColor(), cc -> new java.util.ArrayList<>()).add(c);
    }

    // Marcar que este jugador ya eligió
    estado.pendientesEleccion.remove(playerId);
    broadcast("[info] " + (j.nombre != null ? j.nombre : playerId) + " eligió sus 2 cartas finales.");

    // ¿Todos eligieron? -> cerrar partida, puntuar y avisar
    if (estado.pendientesEleccion.isEmpty()) {
      estado.turnoDe = null;
      estado.juegoTerminado = true;

      // Clasificación persistente (si usás ranking)
      java.util.List<modelo.puntaje.EntradaClasificacion> clasif = buildClasificacionFinal(estado);
      modelo.puntaje.TablaClasificacion.appendAll(clasif);

      String resumen = computeScores(estado);
      broadcast("Fin de juego");
      broadcast(resumen);
    }

    push();  // refrescar estado a todos
  }



  @Override
  public synchronized EstadoJuego getSnapshot() {
    return sanitizeAllHideHands();
  }
  @Override
  public synchronized void saveGame() {
      try {
          Persistencia.save(estado);
          broadcast("[info] Partida guardada correctamente.");
          System.out.println("✓ Partida guardada: " + estado.jugadores.size() + " jugadores, " + 
                            estado.cartasMazoRestantes + " cartas en mazo");
      } catch (Exception e) {
          broadcast("[error] Error al guardar: " + e.getMessage());
          System.err.println("ERROR guardando: " + e);
          e.printStackTrace();
      }
  }

  @Override
  public synchronized void loadGame() {
      try {
          // VERIFICACIÓN MEJORADA: Solo cargar si no hay jugadores activos
          if (!clientes.isEmpty()) {
              broadcast("[error] No se puede cargar partida con jugadores conectados. " +
                       "Todos deben salir primero.");
              return;
          }
          
          EstadoJuego saved = Persistencia.load();
          if (saved != null) {
              // COPIAR ESTADO COMPLETO
              copiarEstadoCompleto(saved, this.estado);
              
              // También copiar a jugadores (si usas este map separado)
              jugadores.clear();
              jugadores.putAll(estado.jugadores);
              
              broadcast("[info] Partida cargada ✓. Únanse los mismos jugadores: " + 
                       getNombresJugadoresGuardados());
              System.out.println("✓ Partida cargada: " + estado.jugadores.size() + " jugadores, " +
                                estado.cartasMazoRestantes + " cartas en mazo");
              
              push(); // Notificar a potenciales observadores
          } else {
              broadcast("[info] No hay partida guardada.");
          }
      } catch (Exception e) {
          broadcast("[error] Error al cargar: " + e.getMessage());
          System.err.println("ERROR cargando: " + e);
          e.printStackTrace();
      }
  }



  // Método para mostrar qué jugadores deben unirse
  private String getNombresJugadoresGuardados() {
      if (estado.jugadores.isEmpty()) return "ninguno";
      
      StringBuilder sb = new StringBuilder();
      for (EstadoJuego.Jugador j : estado.jugadores.values()) {
          if (sb.length() > 0) sb.append(", ");
          sb.append(j.nombre);
      }
      return sb.toString();
  }

  @Override
  public synchronized java.util.List<EntradaClasificacion> getTopRanking(int n) {
    return TablaClasificacion.topN(n);
  }

  // === Sanitización de estado (cada cliente ve solo su mano) ===

  private EstadoJuego sanitizeFor(String playerId) {
    var src = this.estado;
    var dst = new EstadoJuego();

    dst.turnoDe = src.turnoDe;
    dst.cartasMazoRestantes = src.cartasMazoRestantes;
    dst.juegoTerminado = src.juegoTerminado;

    // copiar flags de la fase final
    dst.ultimaRonda = src.ultimaRonda;
    dst.causaFin = src.causaFin;
    dst.pendientesEleccion.addAll(src.pendientesEleccion);

    dst.desfile.addAll(src.desfile);

    for (var e : src.jugadores.entrySet()) {
      var j = e.getValue();
      var jj = new EstadoJuego.Jugador();
      jj.id = j.id;
      jj.nombre = j.nombre;

      if (j.id.equals(playerId)) {
        jj.mano.addAll(j.mano);
      }
      for (var pe : j.pilas.entrySet()) {
        jj.pilas.put(pe.getKey(), new ArrayList<>(pe.getValue()));
      }
      dst.jugadores.put(jj.id, jj);
    }
    return dst;
  }

  private EstadoJuego sanitizeAllHideHands() {
    var src = this.estado;
    var dst = new EstadoJuego();
    dst.turnoDe = src.turnoDe;
    dst.cartasMazoRestantes = src.cartasMazoRestantes;
    dst.juegoTerminado = src.juegoTerminado;

    dst.ultimaRonda = src.ultimaRonda;
    dst.causaFin = src.causaFin;
    dst.pendientesEleccion.addAll(src.pendientesEleccion);

    dst.desfile.addAll(src.desfile);
    for (var e : src.jugadores.entrySet()) {
      var j = e.getValue();
      var jj = new EstadoJuego.Jugador();
      jj.id = j.id;
      jj.nombre = j.nombre;
      for (var pe : j.pilas.entrySet()) {
        jj.pilas.put(pe.getKey(), new ArrayList<>(pe.getValue()));
      }
      dst.jugadores.put(jj.id, jj);
    }
    return dst;
  }

  // === Helpers de reglamento / puntaje / ranking ===

  private boolean alguienConSeisColores() {
    for (var j : estado.jugadores.values()) {
      int distintos = 0;
      for (Color c : Color.values()) if (j.pilas.getOrDefault(c, List.of()).size() > 0) distintos++;
      if (distintos >= Color.values().length) return true;
    }
    return false;
  }

  private void activarUltimaRonda(String causa) {
    estado.ultimaRonda = true;
    estado.causaFin = causa;
    estado.turnoDe = null; // ya no hay turnos

    estado.pendientesEleccion.clear();
    for (var j : estado.jugadores.values()) {
      if (j.mano.size() >= 2) {
        estado.pendientesEleccion.add(j.id);
      } else if (!j.mano.isEmpty()) {
        // Si tiene 1 carta la pasamos directo a pilas para no trabar
        for (int k = j.mano.size() - 1; k >= 0; k--) {
          Carta c = j.mano.remove(k);
          j.pilas.computeIfAbsent(c.getColor(), x -> new ArrayList<>()).add(c);
        }
      }
    }
    broadcast("[info] Última ronda: elegí 2 cartas de tu mano para sumar a tus pilas.");
    push();
  }

  private void finalizarPartida() {
    // Persistir ranking
    java.util.List<EntradaClasificacion> clasif = buildClasificacionFinal(estado);
    TablaClasificacion.appendAll(clasif);

    // Resumen
    String resumen = computeScores(estado);
    estado.juegoTerminado = true;

    broadcast("[info] Fin de juego");
    broadcast(resumen);
    push();
  }

  // Mueve automáticamente las 2 cartas de menor valor de la mano a pilas (ya no se usa en la fase nueva)
  private void addTwoLowestFromHand(EstadoJuego.Jugador j) {
    var mano = new ArrayList<Carta>(j.mano);
    mano.sort(Comparator.comparingInt(Carta::getValor));
    int k = Math.min(2, mano.size());
    for (int i = 0; i < k; i++) {
      var c = mano.get(i);
      j.pilas.computeIfAbsent(c.getColor(), x -> new ArrayList<>()).add(c);
      j.mano.remove(c);
    }
  }

  /** Construye las entradas de clasificación final y puntúa según reglamento. */
  private java.util.List<EntradaClasificacion> buildClasificacionFinal(EstadoJuego est) {
    java.util.List<EntradaClasificacion> out = new ArrayList<>();
    java.util.List<EstadoJuego.Jugador> jugadores = new ArrayList<>(est.jugadores.values());
    Color[] colores = Color.values();

    long ahora = System.currentTimeMillis();

    Map<String,Integer> totalCartas = new HashMap<>();
    Map<String,Integer> puntos      = new HashMap<>();
    for (var j : jugadores) { totalCartas.put(j.id, 0); puntos.put(j.id, 0); }

    for (Color color : colores) {
      Map<String,Integer> cnt = new HashMap<>();
      Map<String,Integer> sum = new HashMap<>();

      for (var j : jugadores) {
        var pil = j.pilas.getOrDefault(color, java.util.List.of());
        cnt.put(j.id, pil.size());
        int s = 0; for (Carta c : pil) s += c.getValor();
        sum.put(j.id, s);
        totalCartas.put(j.id, totalCartas.get(j.id) + pil.size());
      }

      // Mayorías (2 jugadores: +2; 3+ jugadores: comparten mayoría los máximos)
      Set<String> conMayoria = new HashSet<>();
      if (jugadores.size() == 2) {
        var a = jugadores.get(0); var b = jugadores.get(1);
        int ca = cnt.get(a.id), cb = cnt.get(b.id);
        if (ca >= cb + 2) conMayoria.add(a.id);
        if (cb >= ca + 2) conMayoria.add(b.id);
      } else {
        int max = jugadores.stream().mapToInt(j -> cnt.get(j.id)).max().orElse(0);
        if (max > 0) for (var j : jugadores) if (cnt.get(j.id) == max) conMayoria.add(j.id);
      }

      for (var j : jugadores) {
        int acc = puntos.get(j.id);
        acc += conMayoria.contains(j.id) ? cnt.get(j.id) : sum.get(j.id);
        puntos.put(j.id, acc);
      }
    }

    for (var j : jugadores) {
      out.add(new EntradaClasificacion(j.nombre, puntos.get(j.id), totalCartas.get(j.id), ahora));
    }
    return out;
  }

  // Calcula puntajes y genera resumen para el log de clientes
  private String computeScores(EstadoJuego est) {
    var jugadoresList = new ArrayList<>(est.jugadores.values());
    var colores = Color.values();

    Map<String,Integer> total       = new LinkedHashMap<>();
    Map<String,Integer> totalCartas = new LinkedHashMap<>();
    for (var j : jugadoresList) { total.put(j.id, 0); totalCartas.put(j.id, 0); }

    for (var color : colores) {
      Map<String,Integer> count = new HashMap<>();
      for (var j : jugadoresList)
        count.put(j.id, j.pilas.getOrDefault(color, java.util.List.of()).size());

      Set<String> mayorias = new HashSet<>();
      if (jugadoresList.size() == 2) {
        var a = jugadoresList.get(0); var b = jugadoresList.get(1);
        int ca = count.get(a.id),     cb = count.get(b.id);
        if (ca >= cb + 2) mayorias.add(a.id);
        if (cb >= ca + 2) mayorias.add(b.id);
      } else {
        int max = jugadoresList.stream().mapToInt(j -> count.get(j.id)).max().orElse(0);
        if (max > 0) for (var j : jugadoresList) if (count.get(j.id) == max) mayorias.add(j.id);
      }

      for (var j : jugadoresList) {
        var cartas = j.pilas.getOrDefault(color, java.util.List.of());
        totalCartas.put(j.id, totalCartas.get(j.id) + cartas.size());
        int suma;
        if (mayorias.contains(j.id)) {
          suma = cartas.size();
        } else {
          int s = 0; for (var c : cartas) s += c.getValor();
          suma = s;
        }
        total.put(j.id, total.get(j.id) + suma);
      }
    }

    var sb = new StringBuilder();
    sb.append("PUNTAJES FINALES (gana menor puntaje)\n");
    for (var j : jugadoresList) {
      sb.append(j.nombre).append(": ").append(total.get(j.id))
        .append(" pts (").append(totalCartas.get(j.id)).append(" cartas)\n");
    }
    var ganador = jugadoresList.get(0);
    for (var j : jugadoresList) {
      int tg = total.get(ganador.id), tj = total.get(j.id);
      if (tj < tg || (tj == tg && totalCartas.get(j.id) < totalCartas.get(ganador.id))) ganador = j;
    }
    sb.append("Ganador: ").append(ganador.nombre);
    return sb.toString();
  }

  // === Notificación a clientes ===

  private void broadcast(String msg) {
    clientes.values().forEach(cb -> { try { cb.onEvent(msg); } catch (Exception ignored) {} });
  }

  private void push() {
    for (var entry : clientes.entrySet()) {
      var pid = entry.getKey();
      var cb  = entry.getValue();
      try {
        cb.onStateUpdate(sanitizeFor(pid));
      } catch (Exception ignored) {}
    }
  }
}
