package servidor;

import persistencia.Persistencia;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.*;

import modelo.core.*;
import modelo.puntaje.EntradaClasificacion;
import modelo.puntaje.TablaClasificacion;
import modelo.reglas.ReglasParade;
import net.*;

public class ServidorJuegoImpl extends UnicastRemoteObject implements ServidorJuegoRemoto {
  private static final long serialVersionUID = 1L;

  private final Map<String, CallbackClienteRemoto> clientes  = new LinkedHashMap<>();
  private final Map<String, EstadoJuego.Jugador>   jugadores = new LinkedHashMap<>();
  private final EstadoJuego estado = new EstadoJuego();
  private final ReglasParade reglas = new ReglasParade();

  public ServidorJuegoImpl() throws RemoteException { super(); }

  // === RMI API ===

  @Override
  public synchronized String join(String nombre, CallbackClienteRemoto cb) throws RemoteException {
      // 1. Buscar si ya existe un jugador con ese nombre
      for (EstadoJuego.Jugador j : estado.jugadores.values()) {
          if (j.nombre.equals(nombre)) {
              // Reutilizamos al jugador existente
              clientes.put(j.id, cb); // actualizar callback
              broadcast("[info] " + nombre + " se reconectó.");
              push();
              return j.id;
          }
      }

      // 2. Si no existe, creamos un jugador nuevo
      String id = UUID.randomUUID().toString();
      var j = new EstadoJuego.Jugador();
      j.id = id;
      j.nombre = nombre;

      jugadores.put(id, j);           // <- si usás también este map
      estado.jugadores.put(id, j);    // <- principal referencia
      clientes.put(id, cb);

      broadcast("Se unió " + nombre);
      push();
      return id;
  }


  @Override
  public synchronized void sendChat(String id, String msg) throws RemoteException {
    String nombre = (estado.jugadores.get(id) != null)
        ? estado.jugadores.get(id).nombre
        : id;
    broadcast("[CHAT] " + nombre + ": " + msg);
  }

  @Override
  public synchronized void start() throws RemoteException {
    var lista = new ArrayList<>(jugadores.values());
    if (lista.size() < 2) { broadcast("[info] Se necesitan al menos 2 jugadores."); return; }

    // reset estado final
    estado.ultimaRonda = false;
    estado.causaFin = null;
    estado.pendientesEleccion.clear();
    estado.juegoTerminado = false;

    reglas.iniciar(estado, lista);
    broadcast("[info] Partida iniciada");
    push();
  }

  @Override
  public synchronized void playCard(String playerId, int handIndex) throws RemoteException {
    var jugadorActual = estado.jugadores.get(playerId);
    if (jugadorActual == null) return;

    if (!Objects.equals(estado.turnoDe, playerId)) {
      var cb = clientes.get(playerId);
      if (cb != null) cb.onEvent("No es tu turno.");
      return;
    }
    if (handIndex < 0 || handIndex >= jugadorActual.mano.size()) {
      var cb = clientes.get(playerId);
      if (cb != null) cb.onEvent("Índice inválido: " + handIndex + " (usa 0.." + (jugadorActual.mano.size()-1) + ")");
      return;
    }

    // Jugar la carta usando reglas
    reglas.jugarCarta(estado, playerId, handIndex);

 // Activar fase final si corresponde (sin mazo o alguien completó 6 colores)
    if (!estado.ultimaRonda) {
      boolean sinMazo = (estado.cartasMazoRestantes <= 0);
      boolean seisColores = estado.jugadores.values().stream()
          .anyMatch(jg -> jg.pilas.keySet().size() >= Color.values().length);

      if (sinMazo || seisColores) {
        estado.ultimaRonda = true;
        estado.causaFin = sinMazo ? "sin_mazo" : "seis_colores";
        estado.turnoDe = null; // ya no hay turnos; cada uno elige sus 2 cartas
        estado.pendientesEleccion.clear();
        estado.pendientesEleccion.addAll(estado.jugadores.keySet());

        broadcast("¡Última ronda! Motivo: " +
            (sinMazo ? "se agotó el mazo" : "un jugador completó los 6 colores") +
            ". Cada jugador debe elegir 2 cartas de su mano para mover a sus pilas.");
        push();
        return;
      }
    }

    // Si no entramos en fase final, solo refrescar estado normal
    push();
  }

  // === FASE FINAL: elección 2 cartas ===
  @Override
  public synchronized void chooseFinalCards(String playerId, int[] indices) throws RemoteException {
    var j = estado.jugadores.get(playerId);
    if (j == null) return;

    // Si no estamos en fase final, aviso y salgo
    if (!estado.ultimaRonda) {
      var cb = clientes.get(playerId);
      if (cb != null) try { cb.onEvent("Aún no es la fase final."); } catch (Exception ignore) {}
      return;
    }
    // Evitar doble envío del mismo jugador
    if (estado.pendientesEleccion == null || !estado.pendientesEleccion.contains(playerId)) {
      var cb = clientes.get(playerId);
      if (cb != null) try { cb.onEvent("Ya registraste tu elección final."); } catch (Exception ignore) {}
      return;
    }

    // Validaciones
    if (indices == null || indices.length != 2) {
      var cb = clientes.get(playerId);
      if (cb != null) try { cb.onEvent("Debés elegir exactamente 2 cartas de tu mano."); } catch (Exception ignore) {}
      return;
    }
    java.util.Set<Integer> set = new java.util.HashSet<>();
    for (int ix : indices) {
      if (ix < 0 || ix >= j.mano.size()) {
        var cb = clientes.get(playerId);
        if (cb != null) try { cb.onEvent("Índice inválido: " + ix); } catch (Exception ignore) {}
        return;
      }
      if (!set.add(ix)) {
        var cb = clientes.get(playerId);
        if (cb != null) try { cb.onEvent("Los índices deben ser distintos."); } catch (Exception ignore) {}
        return;
      }
    }

    // Mover cartas a pilas (orden descendente para no desplazar índices)
    java.util.Arrays.sort(indices);
    for (int k = indices.length - 1; k >= 0; k--) {
      Carta c = j.mano.remove(indices[k]);
      j.pilas.computeIfAbsent(c.getColor(), cc -> new java.util.ArrayList<>()).add(c);
    }

    // Marcar que este jugador ya eligió
    estado.pendientesEleccion.remove(playerId);
    broadcast("[info] " + (j.nombre != null ? j.nombre : playerId) + " eligió sus 2 cartas finales.");

    // ¿Todos eligieron? -> cerrar partida, puntuar y avisar
    if (estado.pendientesEleccion.isEmpty()) {
      estado.turnoDe = null;
      estado.juegoTerminado = true;

      // Clasificación persistente (si usás ranking)
      java.util.List<modelo.puntaje.EntradaClasificacion> clasif = buildClasificacionFinal(estado);
      modelo.puntaje.TablaClasificacion.appendAll(clasif);

      String resumen = computeScores(estado);
      broadcast("Fin de juego");
      broadcast(resumen);
    }

    push();  // refrescar estado a todos
  }



  @Override
  public synchronized EstadoJuego getSnapshot() {
    return sanitizeAllHideHands();
  }

  @Override
  public synchronized void saveGame() {
    Persistencia.save(estado);
  }

  @Override
  public synchronized void loadGame() {
    var s = Persistencia.load();
    // Copiamos campo por campo para mantener referencias
    this.estado.desfile.clear();            this.estado.desfile.addAll(s.desfile);
    this.estado.jugadores.clear();          this.estado.jugadores.putAll(s.jugadores);
    this.estado.turnoDe = s.turnoDe;
    this.estado.cartasMazoRestantes = s.cartasMazoRestantes;
    this.estado.juegoTerminado = s.juegoTerminado;

    // campos de fase final
    this.estado.ultimaRonda = s.ultimaRonda;
    this.estado.causaFin = s.causaFin;
    this.estado.pendientesEleccion.clear();
    this.estado.pendientesEleccion.addAll(s.pendientesEleccion);

    push();
  }

  @Override
  public synchronized java.util.List<EntradaClasificacion> getTopRanking(int n) {
    return TablaClasificacion.topN(n);
  }

  // === Sanitización de estado (cada cliente ve solo su mano) ===

  private EstadoJuego sanitizeFor(String playerId) {
    var src = this.estado;
    var dst = new EstadoJuego();

    dst.turnoDe = src.turnoDe;
    dst.cartasMazoRestantes = src.cartasMazoRestantes;
    dst.juegoTerminado = src.juegoTerminado;

    // copiar flags de la fase final
    dst.ultimaRonda = src.ultimaRonda;
    dst.causaFin = src.causaFin;
    dst.pendientesEleccion.addAll(src.pendientesEleccion);

    dst.desfile.addAll(src.desfile);

    for (var e : src.jugadores.entrySet()) {
      var j = e.getValue();
      var jj = new EstadoJuego.Jugador();
      jj.id = j.id;
      jj.nombre = j.nombre;

      if (j.id.equals(playerId)) {
        jj.mano.addAll(j.mano);
      }
      for (var pe : j.pilas.entrySet()) {
        jj.pilas.put(pe.getKey(), new ArrayList<>(pe.getValue()));
      }
      dst.jugadores.put(jj.id, jj);
    }
    return dst;
  }

  private EstadoJuego sanitizeAllHideHands() {
    var src = this.estado;
    var dst = new EstadoJuego();
    dst.turnoDe = src.turnoDe;
    dst.cartasMazoRestantes = src.cartasMazoRestantes;
    dst.juegoTerminado = src.juegoTerminado;

    dst.ultimaRonda = src.ultimaRonda;
    dst.causaFin = src.causaFin;
    dst.pendientesEleccion.addAll(src.pendientesEleccion);

    dst.desfile.addAll(src.desfile);
    for (var e : src.jugadores.entrySet()) {
      var j = e.getValue();
      var jj = new EstadoJuego.Jugador();
      jj.id = j.id;
      jj.nombre = j.nombre;
      for (var pe : j.pilas.entrySet()) {
        jj.pilas.put(pe.getKey(), new ArrayList<>(pe.getValue()));
      }
      dst.jugadores.put(jj.id, jj);
    }
    return dst;
  }

  // === Helpers de reglamento / puntaje / ranking ===

  private boolean alguienConSeisColores() {
    for (var j : estado.jugadores.values()) {
      int distintos = 0;
      for (Color c : Color.values()) if (j.pilas.getOrDefault(c, List.of()).size() > 0) distintos++;
      if (distintos >= Color.values().length) return true;
    }
    return false;
  }

  private void activarUltimaRonda(String causa) {
    estado.ultimaRonda = true;
    estado.causaFin = causa;
    estado.turnoDe = null; // ya no hay turnos

    estado.pendientesEleccion.clear();
    for (var j : estado.jugadores.values()) {
      if (j.mano.size() >= 2) {
        estado.pendientesEleccion.add(j.id);
      } else if (!j.mano.isEmpty()) {
        // Si tiene 1 carta la pasamos directo a pilas para no trabar
        for (int k = j.mano.size() - 1; k >= 0; k--) {
          Carta c = j.mano.remove(k);
          j.pilas.computeIfAbsent(c.getColor(), x -> new ArrayList<>()).add(c);
        }
      }
    }
    broadcast("[info] Última ronda: elegí 2 cartas de tu mano para sumar a tus pilas.");
    push();
  }

  private void finalizarPartida() {
    // Persistir ranking
    java.util.List<EntradaClasificacion> clasif = buildClasificacionFinal(estado);
    TablaClasificacion.appendAll(clasif);

    // Resumen
    String resumen = computeScores(estado);
    estado.juegoTerminado = true;

    broadcast("[info] Fin de juego");
    broadcast(resumen);
    push();
  }

  // Mueve automáticamente las 2 cartas de menor valor de la mano a pilas (ya no se usa en la fase nueva)
  private void addTwoLowestFromHand(EstadoJuego.Jugador j) {
    var mano = new ArrayList<Carta>(j.mano);
    mano.sort(Comparator.comparingInt(Carta::getValor));
    int k = Math.min(2, mano.size());
    for (int i = 0; i < k; i++) {
      var c = mano.get(i);
      j.pilas.computeIfAbsent(c.getColor(), x -> new ArrayList<>()).add(c);
      j.mano.remove(c);
    }
  }

  /** Construye las entradas de clasificación final y puntúa según reglamento. */
  private java.util.List<EntradaClasificacion> buildClasificacionFinal(EstadoJuego est) {
    java.util.List<EntradaClasificacion> out = new ArrayList<>();
    java.util.List<EstadoJuego.Jugador> jugadores = new ArrayList<>(est.jugadores.values());
    Color[] colores = Color.values();

    long ahora = System.currentTimeMillis();

    Map<String,Integer> totalCartas = new HashMap<>();
    Map<String,Integer> puntos      = new HashMap<>();
    for (var j : jugadores) { totalCartas.put(j.id, 0); puntos.put(j.id, 0); }

    for (Color color : colores) {
      Map<String,Integer> cnt = new HashMap<>();
      Map<String,Integer> sum = new HashMap<>();

      for (var j : jugadores) {
        var pil = j.pilas.getOrDefault(color, java.util.List.of());
        cnt.put(j.id, pil.size());
        int s = 0; for (Carta c : pil) s += c.getValor();
        sum.put(j.id, s);
        totalCartas.put(j.id, totalCartas.get(j.id) + pil.size());
      }

      // Mayorías (2 jugadores: +2; 3+ jugadores: comparten mayoría los máximos)
      Set<String> conMayoria = new HashSet<>();
      if (jugadores.size() == 2) {
        var a = jugadores.get(0); var b = jugadores.get(1);
        int ca = cnt.get(a.id), cb = cnt.get(b.id);
        if (ca >= cb + 2) conMayoria.add(a.id);
        if (cb >= ca + 2) conMayoria.add(b.id);
      } else {
        int max = jugadores.stream().mapToInt(j -> cnt.get(j.id)).max().orElse(0);
        if (max > 0) for (var j : jugadores) if (cnt.get(j.id) == max) conMayoria.add(j.id);
      }

      for (var j : jugadores) {
        int acc = puntos.get(j.id);
        acc += conMayoria.contains(j.id) ? cnt.get(j.id) : sum.get(j.id);
        puntos.put(j.id, acc);
      }
    }

    for (var j : jugadores) {
      out.add(new EntradaClasificacion(j.nombre, puntos.get(j.id), totalCartas.get(j.id), ahora));
    }
    return out;
  }

  // Calcula puntajes y genera resumen para el log de clientes
  private String computeScores(EstadoJuego est) {
    var jugadoresList = new ArrayList<>(est.jugadores.values());
    var colores = Color.values();

    Map<String,Integer> total       = new LinkedHashMap<>();
    Map<String,Integer> totalCartas = new LinkedHashMap<>();
    for (var j : jugadoresList) { total.put(j.id, 0); totalCartas.put(j.id, 0); }

    for (var color : colores) {
      Map<String,Integer> count = new HashMap<>();
      for (var j : jugadoresList)
        count.put(j.id, j.pilas.getOrDefault(color, java.util.List.of()).size());

      Set<String> mayorias = new HashSet<>();
      if (jugadoresList.size() == 2) {
        var a = jugadoresList.get(0); var b = jugadoresList.get(1);
        int ca = count.get(a.id),     cb = count.get(b.id);
        if (ca >= cb + 2) mayorias.add(a.id);
        if (cb >= ca + 2) mayorias.add(b.id);
      } else {
        int max = jugadoresList.stream().mapToInt(j -> count.get(j.id)).max().orElse(0);
        if (max > 0) for (var j : jugadoresList) if (count.get(j.id) == max) mayorias.add(j.id);
      }

      for (var j : jugadoresList) {
        var cartas = j.pilas.getOrDefault(color, java.util.List.of());
        totalCartas.put(j.id, totalCartas.get(j.id) + cartas.size());
        int suma;
        if (mayorias.contains(j.id)) {
          suma = cartas.size();
        } else {
          int s = 0; for (var c : cartas) s += c.getValor();
          suma = s;
        }
        total.put(j.id, total.get(j.id) + suma);
      }
    }

    var sb = new StringBuilder();
    sb.append("PUNTAJES FINALES (gana menor puntaje)\n");
    for (var j : jugadoresList) {
      sb.append(j.nombre).append(": ").append(total.get(j.id))
        .append(" pts (").append(totalCartas.get(j.id)).append(" cartas)\n");
    }
    var ganador = jugadoresList.get(0);
    for (var j : jugadoresList) {
      int tg = total.get(ganador.id), tj = total.get(j.id);
      if (tj < tg || (tj == tg && totalCartas.get(j.id) < totalCartas.get(ganador.id))) ganador = j;
    }
    sb.append("Ganador: ").append(ganador.nombre);
    return sb.toString();
  }

  // === Notificación a clientes ===

  private void broadcast(String msg) {
    clientes.values().forEach(cb -> { try { cb.onEvent(msg); } catch (Exception ignored) {} });
  }

  private void push() {
    for (var entry : clientes.entrySet()) {
      var pid = entry.getKey();
      var cb  = entry.getValue();
      try {
        cb.onStateUpdate(sanitizeFor(pid));
      } catch (Exception ignored) {}
    }
  }
}
